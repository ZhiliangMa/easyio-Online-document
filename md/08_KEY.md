# 08_KEY

## 例程简介

按键驱动。使用 `ESP32的GPIO中断` 和 `FreeRTOS 的 Queue 消息队列`，实现按键事件检测。从而控制LED任务运行状态。

使用 `FreeRTOS` 的 `Task`，创建三个任务：

1. **led_task** ，控制LED闪烁

2. **key_scan_task** ，单独运行一个任务，运行按键检测（滤除按键抖动、短按、长按）

3. **key_catch_task** ，去捕获按键事件，并控制LED任务状态。

使用 `key.c.h` 驱动模块，快速实现 `按键检测` 功能。可滤除按键抖动，并判断出短按、长按。

07_GPIO_INTR_Queue 只是将GPIO中断使用队列的方式去处理，并没有添加多按键事件。而 08_KEY 不止添加了多按键支持，还支持按键消抖 和 短按/长按检测。

【注意】：使用时，需要单独使用一个线程去运行按键检测任务 void key_scan(int key_num, ...)。另外再开一个任务去接收 按键消息队列，以实现对按键事件的处理。


## 硬件连接

|        | LED    | KEY   |
| ------ | ------ | ----- |
| ESP32  | GPIO33 | GPIO0 |


## 运行现象

* LED闪烁。

* 短按BOOT按键(GPIO0)，LED暂停闪烁。

* 长按BOOT按键(GPIO0)，LED继续闪烁。

* 按动 BOOT按键(GPIO0)、USR按键(GPIO27) 时，串口有调试信息输出。包含 按键GPIO序号、按键按下的时长（低电平持续时间）、按键类型（1为短按，2为长按）、系统时间 等内容，便于调试观察。


## 使用详解

- 对于本代码，电路使用按键直连GND。驱动中ESP32默认开启GPIO的上拉电阻。

- 可支持多个GPIO，只要 `MAX_GPIO` 足够大的话。驱动默认支持`GPIO 0~36`。

- 用户需要另外创建队列接收任务，接收 `key_evt_queue` 队列的按键事件。

- `key_evt_queue` 队列接收到的消息类型为 `uint32_t`，其中前两个字节为 按键类型（1短按，2长按），后两个为按键gpio序号，使用时需要拆分。

- 支持消抖、支持短按、长按识别，阈值时间可在 `key.h` 中修改。默认长按时间为`1000ms`以上。

- `void key_scan(int key_num, ...)` 支持输入不定数目的GPIO通道参数，以便用一句函数实现多按键初始化。

- 如需关闭key的信息调试开关，请将 key.h 中的 key_Dlog 设置为0。

- 【注意】：使用时，需要单独使用一个线程去运行按键检测任务 void key_scan(int key_num, ...)。另外再开一个任务去接收 按键消息队列，以实现对按键事件的处理。


## 学习内容

1. 对上节 ESP32的 `GPIO中断操作` 和 `FreeRTOS 的 Queue 消息队列` 的综合应用。

2. 按键软件消抖。

3. 多按键的实现、编码。


## 关键函数

```c
// 按键检测任务
void key_scan(int key_num, ...);

//按键触发事件，的队列句柄（过滤过按键抖动，存储着短按、长按信息事件）供外部应用调用。
// key_evt_queue队列接收到的消息类型为uint32_t，其中前两个字节为 按键类型（1短按，2长按），后两个为按键gpio序号，使用时需要拆分。
xQueueHandle key_evt_queue = NULL;
```


## 注意事项

- `key.h` 定义了按键调试开关，不需要串口输出按键信息时，可将 `key_Dlog` 设置为0。

- `void key_scan(int key_num, ...)` 需要一个单独的任务去运行，推荐栈空间大小不小于4096，以免栈溢出反复重启。

- 另一个单独任务接收到的 `key_evt_queue` 队列数据。类型为 `uint32_t`，其中前两个字节为 `按键类型`（1短按，2长按），后两个字节为按键的`GPIO序号`，使用时需要拆分。
